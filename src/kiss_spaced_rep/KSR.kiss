(import
    datetime.DateTime
    datetime.DateTimeInterval
    kiss_spaced_rep.Card
    kiss_spaced_rep.StudyEngine)

(#when kiss_express
    (loadFrom "kiss-express" "src/ServerUtil.kiss")
    )

(#if kiss_express
        (var &mut req null)
    (var req true))

(var oneDayInterval (DateTimeInterval.create (DateTime.make 1970 1 1) (DateTime.make 1970 1 2)))
(var halfDayInterval (DateTimeInterval.create (DateTime.make 1970 1 1 0) (DateTime.make 1970 1 1 12)))
(var :Array<(StudyEngine,Void->Void)->Void> studyList [])

(function :Void confirmShow [text :StudyEngine engine :Void->Void cc]
    (engine.print text)
    (engine.delayForUserInput cc))

(function :Void basicScore [text :StudyEngine engine :Int->Void resolve]
    (engine.println text)
    (engine.print "Score (0-5): ")
    (engine.getUserInput ->:Void str (resolve (Std.parseInt str))))

(function :Void noConfirmShow [text :StudyEngine engine :Void->Void cc]
    (engine.println text)
    (cc))

(function :Void typeScore [text :StudyEngine engine :Int->Void resolve]
    (engine.print "Your answer: ")
    (engine.getUserInput ->:Void input
        (cond
            ((= text input)
                (engine.println "Correct!")
                (resolve 5))
            (true
                (engine.println "Wrong! Correct answer was $text")
                (resolve 0)))))

(function :Void clozeShow [index textLines :StudyEngine engine :Void->Void cc]
    (doFor [idx &mut line] (enumerate textLines)
        ((if (StringTools.endsWith line "\\")
                {
                    (set line (StringTools.replace line "\\" ""))
                    engine.print
                }
            engine.println)

            (if (= idx index)
                    "???? "
                (if (StringTools.startsWith line "?")
                        (line.substr 1)
                    line))))
    (engine.delayForUserInput cc))

(function :Void clozeScore [index :Array<String> textLines :StudyEngine engine :Int->Void resolve]
    (basicScore (StringTools.replace (.substr (nth textLines index) 1) "\\" "") engine resolve))

(function :CardSide basicText [:String text]
    (object
        show (confirmShow.bind text)
        score (basicScore.bind text)))

(function :CardSide typeText [:String text]
    (object
        show (noConfirmShow.bind text)
        score (typeScore.bind text)))

(function :CardSide image [:String path &opt :String caption]
    (object
        show ->:Void [engine cc] {(when caption (engine.print caption)) (engine.showImage path) (engine.delayForUserInput cc)}

        score ->:Void [engine :Int->Void resolve] {(when caption (engine.print caption))(engine.showImage path)(engine.print "Score (0-5): ")(engine.getUserInput ->:Void str (resolve (Std.parseInt str)))}))

(defMacroVar cardId 0)
(defMacroVar groupId 0)

(defMacro group [&body body]
    (setMacroVar groupId (+ groupId 1))
    (setMacroVar cardId 0)
    `{,@body})

(defMacroVar _weight 1.0)
(defMacro setWeight [weightV]
    (setMacroVar _weight (eval weightV))
    `null)
(defMacro weight [weightV &body body]
    `{
        ,`(setWeight ,weightV)
        ,@body
        ,`(setWeight 1.0)
    })

(defMacroVar propMacro
    (#if kiss_express
            `userProp
        `savedVar))

(defMacro card [front back &builder b]
    (let [idSymbol ->name (b.symbol "${name}${groupId}_${cardId}")
            cObject (idSymbol "cObject")
            cScore (idSymbol "cScore")
            cRepetitions (idSymbol "cRepetitions")
            cPreviousEaseFactor (idSymbol "cPreviousEaseFactor")
            cPreviousInterval (idSymbol "cPreviousInterval")
            cNextDate (idSymbol "cNextDate")
            cStudy (idSymbol "cStudy")
            nonFractionalWeight (Std.int _weight)
            fractionalWeight (- _weight nonFractionalWeight)
            resolvedFractionalWeight (if (< (Math.random) fractionalWeight) 1 0)
            resolvedWeight (+ nonFractionalWeight resolvedFractionalWeight)
            blockOpenExps
                (#if kiss_express
                        `[withUserProps [,cRepetitions ,cPreviousEaseFactor ,cPreviousInterval ,cNextDate] req]
                    `[begin])]
        (setMacroVar cardId (+ cardId 1))
        `{
            (var ,cObject (object front ,front back ,back))
            (,propMacro :Int ,cRepetitions 0)
            (,propMacro :Float ,cPreviousEaseFactor 2.5)
            (,propMacro :Int ,cPreviousInterval 0)
            (,propMacro :Float ,cNextDate (DateTime.make))

            (if req
                    (,@blockOpenExps
                        (let [:DateTime nextDate ,cNextDate]
                            (localFunction :Void ,cStudy [:StudyEngine engine :Void->Void cc]
                                (when req
                                    (localFunction :Void ,cScore [:Int quality]
                                        (,@blockOpenExps
                                            (localVar &mut interval 0)
                                            (cond
                                                ((>= quality 3)
                                                    (set interval (Math.ceil (case ,cRepetitions (0 1) (1 6) (more (* ,cPreviousEaseFactor ,cPreviousInterval)) (never otherwise))))
                                                    (+= ,cRepetitions 1)
                                                    (set ,cPreviousEaseFactor (+ ,cPreviousEaseFactor (- 0.1 (* (- 5 quality) (+ 0.08 (* (- 5 quality ) 0.02)))))))
                                                (true
                                                    (set ,cRepetitions 0)
                                                    (set interval 1)))
                                            (set ,cPreviousEaseFactor (max 1.3 ,cPreviousEaseFactor))
                                            (set ,cPreviousInterval interval)
                                            (let [&mut :DateTime cNextDate (DateTime.now)]
                                                #{cNextDate += halfDayInterval;}#
                                                (doFor _ (range (- interval 1))
                                                    #{cNextDate += oneDayInterval;}#)
                                                (set ,cNextDate cNextDate))
                                            (cc)
                                            null))
                                    (,@blockOpenExps
                                        (engine.clear)
                                        (if (or #{DateTime.now() > nextDate;}# (#if debug true false))
                                                (.show .front ,cObject engine
                                                    ->:Void
                                                        (.score .back ,cObject engine ,cScore))
                                            {
                                                (engine.println "skipping a card until $(nextDate.toString)")
                                                (cc)
                                            })
                                        null)))
                            ,@(for i (range resolvedWeight)
                                `(studyList.push ,cStudy))
                            null))
                ,@(for i (range resolvedWeight)
                    `(studyList.push ->:Void [:StudyEngine _ :Void->Void cc] (cc))))
        }))

(defMacro reversed [front back]
    `(group
        (card ,front ,back)
        (card ,back ,front)))

(defMacro cloze [&builder b &body textLines]
    (let [cardDecls []]
        (doFor [i line] (enumerate textLines)
            (let [line (eval line)]
                (when (StringTools.startsWith line "?")
                    (cardDecls.push
                        `(card
                            (object
                                show (clozeShow.bind ,i ,textLines)
                                score ->:Void _ 0)
                            (object
                                show ->:Void _ 0
                                score (clozeScore.bind ,i ,textLines)))))))
        (b.callSymbol "group" cardDecls)))

(function :Void studyAll [:StudyEngine engine]
    (if studyList
            (let [nextIndex (Std.random studyList.length)
                    nextToStudy (nth studyList nextIndex)]
                (studyList.splice nextIndex 1)
                (nextToStudy engine (studyAll.bind engine)))
        {
            (engine.clear)
            (engine.println "All cards studied")
            (engine.promptForRefresh ->(studyAll engine))
        }))

(defReaderMacro ["*" "?"] [stream &builder b]
    (let [elements []]
        (loop
            (let [line (expect stream "An element for a cloze sequence" takeLine)]
                (case (line.charAt 0)
                    ("*" (elements.push (b.str (line.substr 1))))
                    ("?" (elements.push (b.str line)))
                    ("" (break))
                    (otherwise (throw "bad element for a cloze sequence: $line")))))
        `(cloze ,@elements)))

(defMacroFunction btDefault [exp]
    (case (Type.enumConstructor exp.def)
        ("StrExp"
            `(basicText ,exp))
        (otherwise exp)))

(defReaderMacro "=>" [stream]
    `(card ,(btDefault (read stream)) ,(btDefault (read stream))))

(defReaderMacro "<=>" [stream]
    `(reversed ,(btDefault (read stream)) ,(btDefault (read stream))))
